<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trading Sight - Integrated Virtual Brokerage Demo</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #1a1a1a;
            color: #ffffff;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        h1 {
            color: #00ff00;
            text-align: center;
            margin-bottom: 20px;
        }
        
        .demo-grid {
            display: grid;
            grid-template-columns: 1fr 300px;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .chart-container {
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 8px;
            padding: 10px;
            position: relative;
        }
        
        canvas {
            width: 100%;
            height: 500px;
            background: #1e1e1e;
            border: 1px solid #333;
            border-radius: 4px;
        }
        
        .controls {
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 8px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .stat-card {
            background: #333;
            padding: 15px;
            border-radius: 6px;
            border-left: 4px solid #00ff00;
        }
        
        .stat-label {
            font-size: 12px;
            color: #888;
            text-transform: uppercase;
            margin-bottom: 5px;
        }
        
        .stat-value {
            font-size: 24px;
            font-weight: bold;
        }
        
        .stat-value.positive {
            color: #00ff00;
        }
        
        .stat-value.negative {
            color: #ff4444;
        }
        
        .trade-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #444;
            border-radius: 4px;
            padding: 10px;
        }
        
        .trade-item {
            background: #333;
            padding: 10px;
            margin-bottom: 5px;
            border-radius: 4px;
            border-left: 4px solid #fff;
        }
        
        .trade-item.open {
            border-left-color: #00ff00;
        }
        
        .trade-item.closed {
            border-left-color: #ff4444;
        }
        
        .trade-header {
            display: flex;
            justify-content: space-between;
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .trade-details {
            font-size: 12px;
            color: #ccc;
        }
        
        button {
            background: #00ff00;
            color: #000;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.2s;
        }
        
        button:hover {
            background: #00cc00;
        }
        
        button.secondary {
            background: #444;
            color: #fff;
        }
        
        button.secondary:hover {
            background: #555;
        }
        
        .input-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        input, select {
            background: #444;
            border: 1px solid #666;
            color: #fff;
            padding: 8px;
            border-radius: 4px;
            font-size: 14px;
        }
        
        .legend {
            display: flex;
            gap: 15px;
            font-size: 12px;
            color: #888;
            margin-top: 10px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .legend-color {
            width: 12px;
            height: 2px;
            background: #fff;
        }
        
        .legend-color.sl {
            background: #ff4444;
            opacity: 0.8;
        }
        
        .legend-color.tp {
            background: #44ff44;
            opacity: 0.8;
        }
        
        .replay-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-top: 10px;
        }
        
        .current-price {
            font-size: 18px;
            font-weight: bold;
            color: #00ff00;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Trading Sight - Virtual Brokerage with Candles</h1>
        
        <div class="demo-grid">
            <div class="chart-container">
                <canvas id="chart" width="900" height="500"></canvas>
                <div class="legend">
                    <div class="legend-item"><div class="legend-color"></div> Entry Price</div>
                    <div class="legend-item"><div class="legend-color sl"></div> Stop Loss</div>
                    <div class="legend-item"><div class="legend-color tp"></div> Take Profit</div>
                </div>
                <div class="replay-controls">
                    <span class="current-price" id="currentPrice">Current: $100.0000</span>
                    <button id="playBtn">Play</button>
                    <button id="pauseBtn">Pause</button>
                    <button id="stepBtn">Step</button>
                </div>
            </div>
            
            <div class="controls">
                <h3>Broker Controls</h3>
                
                <div class="input-group">
                    <label for="tradeType">Trade Type</label>
                    <select id="tradeType">
                        <option value="buy">Buy</option>
                        <option value="sell">Sell</option>
                    </select>
                </div>
                
                <div class="input-group">
                    <label for="entryPrice">Entry Price</label>
                    <input type="number" id="entryPrice" step="0.0001" value="100.0000">
                </div>
                
                <div class="input-group">
                    <label for="stopLoss">Stop Loss</label>
                    <input type="number" id="stopLoss" step="0.0001" value="99.9000">
                </div>
                
                <div class="input-group">
                    <label for="takeProfit">Take Profit</label>
                    <input type="number" id="takeProfit" step="0.0001" value="100.1000">
                </div>
                
                <div class="input-group">
                    <label for="lotSize">Lot Size</label>
                    <input type="number" id="lotSize" step="0.01" value="0.1">
                </div>
                
                <button id="placeOrderBtn">Place Order</button>
                <button id="closeAllBtn" class="secondary">Close All Positions</button>
                <button id="resetBtn" class="secondary">Reset Broker</button>
            </div>
        </div>
        
        <div class="stats-grid">
            <div class="stat-card">
                <div class="stat-label">Balance</div>
                <div class="stat-value" id="balance">$10,000.00</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Equity</div>
                <div class="stat-value" id="equity">$10,000.00</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Unrealized P&L</div>
                <div class="stat-value" id="unrealizedPnL">$0.00</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Win Rate</div>
                <div class="stat-value" id="winRate">0%</div>
            </div>
        </div>
        
        <div class="controls">
            <h3>Trade History</h3>
            <div class="trade-list" id="tradeList">
                <div style="color: #666; text-align: center; padding: 20px;">No trades yet</div>
            </div>
        </div>
    </div>

    <script>
        // Chart rendering engine (simplified version)
        class SimpleChart {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.data = [];
                this.width = canvas.width;
                this.height = canvas.height;
                this.offset = 0;
                this.zoom = 20; // pixels per candle
                this.priceOffset = 0;
                this.currentPrice = 100;
            }
            
            setData(data) {
                this.data = data;
                this.draw();
            }
            
            draw() {
                this.clear();
                this.drawBackground();
                this.drawGrid();
                this.drawCandles();
                this.drawPriceAxis();
                this.drawFPS();
            }
            
            clear() {
                this.ctx.clearRect(0, 0, this.width, this.height);
            }
            
            drawBackground() {
                this.ctx.fillStyle = '#1e1e1e';
                this.ctx.fillRect(0, 0, this.width, this.height);
                
                this.ctx.strokeStyle = '#333';
                this.ctx.lineWidth = 1;
                this.ctx.strokeRect(0, 0, this.width, this.height);
            }
            
            drawGrid() {
                this.ctx.strokeStyle = '#333';
                this.ctx.lineWidth = 1;
                this.ctx.setLineDash([2, 4]);
                
                // Draw horizontal grid lines
                const priceRange = this.getPriceRange();
                const steps = this.calculatePriceSteps(priceRange.min, priceRange.max);
                
                steps.forEach(price => {
                    const y = this.priceToY(price);
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y);
                    this.ctx.lineTo(this.width, y);
                    this.ctx.stroke();
                });
                
                this.ctx.setLineDash([]);
            }
            
            drawCandles() {
                if (this.data.length === 0) return;
                
                const visibleRange = this.getVisibleRange();
                const priceRange = this.getPriceRange();
                
                for (let i = visibleRange.startIndex; i <= visibleRange.endIndex; i++) {
                    const candle = this.data[i];
                    if (!candle) continue;
                    
                    const x = this.indexToX(i);
                    const xRounded = Math.round(x);
                    
                    // Calculate Y coordinates
                    const range = priceRange.max - priceRange.min;
                    const openY = this.height - ((candle.open - priceRange.min) / range) * this.height;
                    const closeY = this.height - ((candle.close - priceRange.min) / range) * this.height;
                    const highY = this.height - ((candle.high - priceRange.min) / range) * this.height;
                    const lowY = this.height - ((candle.low - priceRange.min) / range) * this.height;
                    
                    // Draw wick
                    this.ctx.strokeStyle = '#fff';
                    this.ctx.lineWidth = 1;
                    this.ctx.beginPath();
                    this.ctx.moveTo(xRounded, Math.round(highY));
                    this.ctx.lineTo(xRounded, Math.round(lowY));
                    this.ctx.stroke();
                    
                    // Draw body
                    const bodyY = Math.round(Math.min(openY, closeY));
                    const bodyHeight = Math.max(Math.abs(Math.round(closeY) - Math.round(openY)), 1);
                    const isBullish = candle.close >= candle.open;
                    
                    this.ctx.fillStyle = isBullish ? '#00ff00' : '#ff0000';
                    this.ctx.fillRect(xRounded - 3, bodyY, 6, bodyHeight);
                }
            }
            
            drawPriceAxis() {
                this.ctx.fillStyle = '#ccc';
                this.ctx.font = '12px Arial';
                this.ctx.textAlign = 'right';
                
                const priceRange = this.getPriceRange();
                const steps = this.calculatePriceSteps(priceRange.min, priceRange.max);
                
                steps.forEach(price => {
                    const y = this.priceToY(price);
                    this.ctx.fillText(price.toFixed(4), this.width - 10, y);
                });
            }
            
            drawFPS() {
                this.ctx.fillStyle = '#fff';
                this.ctx.font = '12px Arial';
                this.ctx.textAlign = 'left';
                this.ctx.fillText(`Candles: ${this.data.length}`, 10, 20);
            }
            
            // Coordinate conversion methods
            indexToX(index) {
                return (index - this.offset) * this.zoom;
            }
            
            priceToY(price) {
                const priceRange = this.getPriceRange();
                const range = priceRange.max - priceRange.min;
                return this.height - ((price - priceRange.min) / range) * this.height;
            }
            
            getPriceRange() {
                if (this.data.length === 0) return { min: 99, max: 101 };
                
                const visibleRange = this.getVisibleRange();
                let min = Infinity;
                let max = -Infinity;
                
                for (let i = visibleRange.startIndex; i <= visibleRange.endIndex; i++) {
                    const candle = this.data[i];
                    if (candle) {
                        min = Math.min(min, candle.low);
                        max = Math.max(max, candle.high);
                    }
                }
                
                // Add some padding
                const padding = (max - min) * 0.1;
                return { min: min - padding, max: max + padding };
            }
            
            getVisibleRange() {
                const startIndex = Math.max(0, Math.floor(this.offset));
                const endIndex = Math.min(this.data.length - 1, startIndex + Math.ceil(this.width / this.zoom));
                return { startIndex, endIndex };
            }
            
            calculatePriceSteps(min, max) {
                const range = max - min;
                const step = Math.pow(10, Math.floor(Math.log10(range)) - 1);
                const start = Math.floor(min / step) * step;
                const steps = [];
                
                for (let price = start; price <= max; price += step) {
                    if (price >= min) {
                        steps.push(price);
                    }
                }
                
                return steps;
            }
            
            updateCurrentPrice(price) {
                this.currentPrice = price;
                // Draw current price line
                const y = this.priceToY(price);
                this.ctx.strokeStyle = '#ffff00';
                this.ctx.lineWidth = 1;
                this.ctx.setLineDash([5, 5]);
                this.ctx.beginPath();
                this.ctx.moveTo(0, y);
                this.ctx.lineTo(this.width, y);
                this.ctx.stroke();
                this.ctx.setLineDash([]);
            }
        }
        
        // Mock data generation
        function generateOHLCData(count = 500) {
            const data = [];
            let price = 100;
            
            for (let i = 0; i < count; i++) {
                const time = Date.now() - (count - i) * 60000;
                const volatility = 0.005 + Math.random() * 0.01;
                
                const change = (Math.random() - 0.5) * volatility;
                price += change;
                
                const open = price;
                const close = price + (Math.random() - 0.5) * volatility;
                const high = Math.max(open, close) + Math.random() * volatility;
                const low = Math.min(open, close) - Math.random() * volatility;
                
                data.push({
                    time,
                    open: Math.round(open * 10000) / 10000,
                    high: Math.round(high * 10000) / 10000,
                    low: Math.round(low * 10000) / 10000,
                    close: Math.round(close * 10000) / 10000
                });
            }
            
            return data;
        }
        
        // Mock BrokerEngine
        class MockBrokerEngine {
            constructor(initialBalance = 10000) {
                this.balance = initialBalance;
                this.equity = initialBalance;
                this.positions = [];
                this.tradeCounter = 0;
                this.eventCallbacks = [];
            }
            
            placeOrder(type, price, sl, tp, size = 0.1) {
                const trade = {
                    id: `trade_${++this.tradeCounter}`,
                    type,
                    entryPrice: price,
                    sl,
                    tp,
                    size,
                    entryTime: Date.now(),
                    status: 'open',
                    unrealizedPnL: 0
                };
                
                this.positions.push(trade);
                this.updateEquity();
                this.emitEvent('TRADE_OPENED', trade);
                return trade;
            }
            
            update(currentPrice) {
                this.positions.forEach(trade => {
                    if (trade.status === 'open') {
                        trade.unrealizedPnL = this.calculatePnL(trade, currentPrice);
                        
                        if (trade.type === 'buy') {
                            if (currentPrice <= trade.sl) {
                                this.closeTrade(trade.id, trade.sl);
                            } else if (currentPrice >= trade.tp) {
                                trade.status = 'taken';
                                this.closeTrade(trade.id, trade.tp);
                            }
                        } else {
                            if (currentPrice >= trade.sl) {
                                this.closeTrade(trade.id, trade.sl);
                            } else if (currentPrice <= trade.tp) {
                                trade.status = 'taken';
                                this.closeTrade(trade.id, trade.tp);
                            }
                        }
                    }
                });
                
                this.updateEquity();
            }
            
            closeTrade(tradeId, exitPrice) {
                const trade = this.positions.find(t => t.id === tradeId && t.status === 'open');
                if (!trade) return null;
                
                trade.exitPrice = exitPrice;
                trade.exitTime = Date.now();
                trade.status = 'stopped';
                trade.realizedPnL = this.calculatePnL(trade, exitPrice);
                
                this.balance += trade.realizedPnL;
                this.updateEquity();
                this.emitEvent('TRADE_CLOSED', trade);
                
                return trade;
            }
            
            calculatePnL(trade, exitPrice) {
                if (trade.type === 'buy') {
                    return (exitPrice - trade.entryPrice) * trade.size * 100000;
                } else {
                    return (trade.entryPrice - exitPrice) * trade.size * 100000;
                }
            }
            
            updateEquity() {
                const unrealizedPnL = this.positions
                    .filter(t => t.status === 'open')
                    .reduce((total, trade) => total + trade.unrealizedPnL, 0);
                this.equity = this.balance + unrealizedPnL;
            }
            
            getOpenPositions() {
                return this.positions.filter(t => t.status === 'open');
            }
            
            getClosedPositions() {
                return this.positions.filter(t => t.status !== 'open');
            }
            
            onTradeEvent(callback) {
                this.eventCallbacks.push(callback);
            }
            
            emitEvent(type, trade) {
                this.eventCallbacks.forEach(cb => cb({ type, trade, timestamp: Date.now() }));
            }
        }
        
        // Demo initialization
        const data = generateOHLCData(500);
        const chart = new SimpleChart(document.getElementById('chart'));
        const broker = new MockBrokerEngine(10000);
        
        // DOM elements
        const balanceEl = document.getElementById('balance');
        const equityEl = document.getElementById('equity');
        const unrealizedPnLEl = document.getElementById('unrealizedPnL');
        const winRateEl = document.getElementById('winRate');
        const tradeListEl = document.getElementById('tradeList');
        const currentPriceEl = document.getElementById('currentPrice');
        
        // Initialize chart
        chart.setData(data);
        
        // Update UI
        function updateUI() {
            balanceEl.textContent = `$${broker.balance.toFixed(2)}`;
            equityEl.textContent = `$${broker.equity.toFixed(2)}`;
            
            const unrealizedPnL = broker.equity - broker.balance;
            unrealizedPnLEl.textContent = `$${unrealizedPnL.toFixed(2)}`;
            unrealizedPnLEl.className = `stat-value ${unrealizedPnL >= 0 ? 'positive' : 'negative'}`;
            
            const closedPositions = broker.getClosedPositions();
            const wins = closedPositions.filter(t => (t.realizedPnL || 0) > 0).length;
            const winRate = closedPositions.length > 0 ? (wins / closedPositions.length) * 100 : 0;
            winRateEl.textContent = `${winRate.toFixed(1)}%`;
            
            // Update trade list
            tradeListEl.innerHTML = '';
            const allTrades = [...broker.getOpenPositions(), ...broker.getClosedPositions()]
                .sort((a, b) => b.entryTime - a.entryTime);
            
            if (allTrades.length === 0) {
                tradeListEl.innerHTML = '<div style="color: #666; text-align: center; padding: 20px;">No trades yet</div>';
            } else {
                allTrades.forEach(trade => {
                    const div = document.createElement('div');
                    div.className = `trade-item ${trade.status === 'open' ? 'open' : 'closed'}`;
                    
                    const header = document.createElement('div');
                    header.className = 'trade-header';
                    header.innerHTML = `
                        <span>${trade.type.toUpperCase()} ${trade.status.toUpperCase()}</span>
                        <span>$${(trade.realizedPnL || trade.unrealizedPnL || 0).toFixed(2)}</span>
                    `;
                    
                    const details = document.createElement('div');
                    details.className = 'trade-details';
                    details.innerHTML = `
                        Entry: $${trade.entryPrice} | SL: $${trade.sl} | TP: $${trade.tp} | Size: ${trade.size}
                    `;
                    
                    div.appendChild(header);
                    div.appendChild(details);
                    tradeListEl.appendChild(div);
                });
            }
        }
        
        // Event listeners
        broker.onTradeEvent(() => updateUI());
        
        // Chart rendering with trades
        function renderChartWithTrades() {
            chart.draw();
            
            // Draw trades on chart
            const openPositions = broker.getOpenPositions();
            openPositions.forEach(trade => {
                // Draw entry line
                const entryY = chart.priceToY(trade.entryPrice);
                chart.ctx.strokeStyle = '#ffffff';
                chart.ctx.lineWidth = 1;
                chart.ctx.beginPath();
                chart.ctx.moveTo(0, entryY);
                chart.ctx.lineTo(chart.width, entryY);
                chart.ctx.stroke();
                
                // Draw SL line (dashed red)
                const slY = chart.priceToY(trade.sl);
                chart.ctx.strokeStyle = '#ff4444';
                chart.ctx.setLineDash([5, 5]);
                chart.ctx.beginPath();
                chart.ctx.moveTo(0, slY);
                chart.ctx.lineTo(chart.width, slY);
                chart.ctx.stroke();
                
                // Draw TP line (dashed green)
                const tpY = chart.priceToY(trade.tp);
                chart.ctx.strokeStyle = '#44ff44';
                chart.ctx.beginPath();
                chart.ctx.moveTo(0, tpY);
                chart.ctx.lineTo(chart.width, tpY);
                chart.ctx.stroke();
                
                chart.ctx.setLineDash([]);
            });
            
            // Draw current price line
            const currentPrice = currentIndex < data.length ? data[currentIndex].close : (data[data.length - 1]?.close || 100);
            chart.updateCurrentPrice(currentPrice);
            currentPriceEl.textContent = `Current: $${currentPrice.toFixed(4)}`;
        }
        
        // Replay controls
        let currentIndex = 0;
        let isPlaying = false;
        let animationId = null;
        
        function play() {
            if (isPlaying) return;
            isPlaying = true;
            playLoop();
        }
        
        function pause() {
            isPlaying = false;
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
        }
        
        function step() {
            if (currentIndex < data.length) {
                const currentPrice = data[currentIndex].close;
                broker.update(currentPrice);
                currentIndex++;
                renderChartWithTrades();
                updateUI();
            }
        }
        
        function playLoop() {
            if (!isPlaying) return;
            
            if (currentIndex < data.length) {
                const currentPrice = data[currentIndex].close;
                broker.update(currentPrice);
                currentIndex++;
                renderChartWithTrades();
                updateUI();
                
                // Use setTimeout instead of requestAnimationFrame for better control
                animationId = setTimeout(playLoop, 1000); // 1 second delay between candles
            } else {
                pause();
            }
        }
        
        // Event listeners for controls
        document.getElementById('placeOrderBtn').addEventListener('click', () => {
            const type = document.getElementById('tradeType').value;
            const entryPrice = parseFloat(document.getElementById('entryPrice').value);
            const sl = parseFloat(document.getElementById('stopLoss').value);
            const tp = parseFloat(document.getElementById('takeProfit').value);
            const size = parseFloat(document.getElementById('lotSize').value);
            
            broker.placeOrder(type, entryPrice, sl, tp, size);
            renderChartWithTrades();
            updateUI();
        });
        
        document.getElementById('closeAllBtn').addEventListener('click', () => {
            const openPositions = broker.getOpenPositions();
            openPositions.forEach(trade => broker.closeTrade(trade.id, broker.equity > broker.balance ? trade.tp : trade.sl));
            renderChartWithTrades();
            updateUI();
        });
        
        document.getElementById('resetBtn').addEventListener('click', () => {
            broker.positions = [];
            broker.balance = 10000;
            broker.equity = 10000;
            currentIndex = 0;
            renderChartWithTrades();
            updateUI();
        });
        
        document.getElementById('playBtn').addEventListener('click', play);
        document.getElementById('pauseBtn').addEventListener('click', pause);
        document.getElementById('stepBtn').addEventListener('click', step);
        
        // Initialize UI and chart
        updateUI();
        renderChartWithTrades();
    </script>
</body>
</html> <environment_details>
# Visual Studio Code Visible Files
docs/VIRTUAL_BROKERAGE_EXPLAINED.md

# Visual Studio Code Open Tabs
tsconfig.json
tsconfig.node.json
vite.config.ts
index.html
src/react/index.ts
demo/interaction-replay-demo.html
src/core/CoordinateManager.ts
src/core/index.ts
src/core/types.ts
src/core/BrokerEngine.ts
src/layers/TradePainter.ts
src/core/ReplayController.ts
src/hooks/useBroker.ts
src/core/Chart.ts
demo/virtual-brokerage-demo.html
docs/VIRTUAL_BROKERAGE.md
docs/VIRTUAL_BROKERAGE_EXPLAINED.md
demo/integrated-brokerage-demo.html
src/react/TradingSight.tsx
src/main.tsx
package.json
demo/index.html
.gitignore
src/core/InteractionManager.ts
src/core/CandlePainter.ts
src/index.ts
README.md
TESTING.md

# Current Time
2/24/2026, 8:19:20 PM (Asia/Singapore, UTC+8:00)

# Context Window Usage
114,039 / 256K tokens used (45%)

# Current Mode
ACT MODE
</environment_details>