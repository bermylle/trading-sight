<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trading Sight - Interaction & Replay Demo</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #1a1a1a;
            color: #ffffff;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        h1 {
            color: #00ff00;
            text-align: center;
            margin-bottom: 10px;
        }
        
        .demo-grid {
            display: grid;
            grid-template-columns: 1fr 300px;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .chart-container {
            position: relative;
            background: #1e1e1e;
            border: 1px solid #333;
            border-radius: 4px;
            overflow: hidden;
        }
        
        canvas {
            display: block;
            width: 100%;
            height: 500px;
            background: #1e1e1e;
            cursor: crosshair;
        }
        
        .controls-panel {
            background: #2a2a2a;
            padding: 15px;
            border-radius: 4px;
            border: 1px solid #333;
        }
        
        .control-group {
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid #444;
        }
        
        .control-group:last-child {
            border-bottom: none;
        }
        
        h3 {
            margin: 0 0 10px 0;
            font-size: 14px;
            color: #00ff00;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .stats {
            background: #2a2a2a;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 20px;
            font-family: monospace;
            font-size: 12px;
        }
        
        .btn-group {
            display: flex;
            gap: 5px;
            margin-bottom: 10px;
        }
        
        button {
            background: #333;
            color: white;
            border: 1px solid #555;
            padding: 8px 12px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            flex: 1;
        }
        
        button:hover {
            background: #444;
        }
        
        button.primary {
            background: #00ff00;
            color: #000;
            border-color: #00ff00;
        }
        
        button.primary:hover {
            background: #00cc00;
        }
        
        button.warning {
            background: #ffaa00;
            color: #000;
            border-color: #ffaa00;
        }
        
        button.warning:hover {
            background: #ff8800;
        }
        
        .slider-group {
            margin-bottom: 10px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
            color: #888;
        }
        
        input[type="range"] {
            width: 100%;
            cursor: pointer;
        }
        
        .legend {
            margin-top: 10px;
            font-size: 11px;
            color: #666;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 4px;
        }
        
        .color-box {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }
        
        .ghost-indicator {
            opacity: 0.1;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Trading Sight - Interaction & Replay Demo</h1>
        
        <div class="stats" id="stats">
            FPS: 0 | Zoom: 10.00 | Offset: 0 | Visible: 0 - 0 | Data: 0 candles | Tick: 0 | Speed: 1000ms
        </div>
        
        <div class="demo-grid">
            <div class="chart-container">
                <canvas id="chartCanvas"></canvas>
                <div class="legend">
                    <div class="legend-item">
                        <div class="color-box" style="background: #00ff00;"></div>
                        <span>Bullish Candle (Revealed)</span>
                    </div>
                    <div class="legend-item">
                        <div class="color-box ghost-indicator" style="background: #00ff00;"></div>
                        <span>Ghost Candle (Hidden/Future)</span>
                    </div>
                    <div class="legend-item">
                        <div class="color-box" style="background: #ff0000;"></div>
                        <span>Bearish Candle (Revealed)</span>
                    </div>
                    <div class="legend-item">
                        <div class="color-box ghost-indicator" style="background: #ff0000;"></div>
                        <span>Ghost Candle (Hidden/Future)</span>
                    </div>
                </div>
            </div>
            
            <div class="controls-panel">
                <div class="control-group">
                    <h3>Interaction Controls</h3>
                    <div class="btn-group">
                        <button onclick="resetView()">Reset View</button>
                        <button onclick="toggleInteraction()">Toggle Interaction</button>
                    </div>
                    <p style="font-size: 11px; color: #888; margin: 5px 0;">
                        <strong>Panning:</strong> Click & drag<br>
                        <strong>Zoom:</strong> Scroll wheel<br>
                        <strong>Price Panning:</strong> Alt + drag<br>
                        <strong>Reset:</strong> Double-click
                    </p>
                </div>
                
                <div class="control-group">
                    <h3>Replay Controls</h3>
                    <div class="btn-group">
                        <button class="primary" onclick="playReplay()">Play</button>
                        <button onclick="pauseReplay()">Pause</button>
                        <button class="warning" onclick="stopReplay()">Stop</button>
                    </div>
                    <div class="btn-group">
                        <button onclick="stepBackward()">Step Back</button>
                        <button onclick="stepForward()">Step Forward</button>
                    </div>
                    <div class="slider-group">
                        <label>Playback Speed: <span id="speedValue">1000</span>ms</label>
                        <input type="range" id="speedSlider" min="100" max="5000" value="1000" oninput="updateSpeed(this.value)">
                    </div>
                    <div class="slider-group">
                        <label>Progress: <span id="progressValue">0%</span></label>
                        <input type="range" id="progressSlider" min="0" max="100" value="0" oninput="seekProgress(this.value)">
                    </div>
                </div>
                
                <div class="control-group">
                    <h3>Chart Info</h3>
                    <div style="font-size: 12px; line-height: 1.5;">
                        <div><strong>Mode:</strong> <span id="modeDisplay">Live</span></div>
                        <div><strong>Current Price:</strong> <span id="currentPrice">-</span></div>
                        <div><strong>Replay Status:</strong> <span id="replayStatus">Stopped</span></div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="legend">
            <p><strong>Features Demonstrated:</strong></p>
            <ul>
                <li><strong>Zoom-to-Cursor:</strong> Zoom keeps the candle under your mouse stable</li>
                <li><strong>Fog of War:</strong> Only revealed candles are fully visible</li>
                <li><strong>Ghost Candles:</strong> Future candles show as faint outlines</li>
                <li><strong>Dirty Flag Optimization:</strong> Only redraws when necessary for 60 FPS</li>
                <li><strong>Replay Controller:</strong> Full playback control with precise timing</li>
                <li><strong>Interaction Manager:</strong> Smooth panning and zooming with proper event handling</li>
            </ul>
        </div>
    </div>

    <script type="module">
        // Import the core modules (this would work in a real build environment)
        // For demo purposes, we'll simulate the core functionality
        
        // Generate sample OHLC data
        function generateSampleData(count = 2000) {
            const data = [];
            let price = 100;
            
            for (let i = 0; i < count; i++) {
                const time = Date.now() - (count - i) * 60000; // 1 minute intervals
                const volatility = 0.5 + Math.random() * 1.5;
                
                const change = (Math.random() - 0.5) * volatility;
                price += change;
                
                const open = price;
                const close = price + (Math.random() - 0.5) * volatility;
                const high = Math.max(open, close) + Math.random() * volatility;
                const low = Math.min(open, close) - Math.random() * volatility;
                
                data.push({
                    time,
                    open: Math.round(open * 100) / 100,
                    high: Math.round(high * 100) / 100,
                    low: Math.round(low * 100) / 100,
                    close: Math.round(close * 100) / 100
                });
            }
            
            return data;
        }

        // Simple coordinate manager implementation for demo
        class DemoCoordinateManager {
            constructor(data, dimensions, zoom = 10, offset = 0, priceOffset = 0) {
                this.data = data;
                this.state = { zoom, offset, priceOffset, canvasDimensions: dimensions };
            }
            
            getVisibleRange() {
                const { zoom, offset, canvasDimensions } = this.state;
                const startIndex = Math.floor(offset / zoom);
                const endIndex = Math.min(
                    startIndex + Math.ceil(canvasDimensions.width / zoom) + 1,
                    this.data.length - 1
                );
                return {
                    startIndex: Math.max(0, startIndex),
                    endIndex: Math.max(0, Math.min(endIndex, this.data.length - 1))
                };
            }
            
            getMinMaxPrice() {
                const { startIndex, endIndex } = this.getVisibleRange();
                let min = Infinity, max = -Infinity;
                
                for (let i = startIndex; i <= endIndex; i++) {
                    const candle = this.data[i];
                    if (candle.low < min) min = candle.low;
                    if (candle.high > max) max = candle.high;
                }
                
                if (min === max) min = max - 1;
                return { min, max };
            }
            
            priceToY(price) {
                const { min, max } = this.getMinMaxPrice();
                const { height } = this.state.canvasDimensions;
                const priceOffset = this.getPriceOffset();
                
                const range = max - min;
                if (range === 0) return height / 2;
                
                // Apply price offset for vertical panning
                const adjustedPrice = price + (priceOffset * range / height);
                const normalized = (adjustedPrice - min) / range;
                return height - (normalized * height);
            }
            
            timeToX(index) {
                const { zoom, offset } = this.state;
                return (index * zoom) - offset;
            }
            
            setZoom(zoom) { this.state.zoom = zoom; }
            setOffset(offset) { this.state.offset = offset; }
            setPriceOffset(priceOffset) { this.state.priceOffset = priceOffset; }
            getZoom() { return this.state.zoom; }
            getOffset() { return this.state.offset; }
            getPriceOffset() { return this.state.priceOffset || 0; }
            getState() { return { ...this.state }; }
        }

        // Simple replay controller implementation
        class DemoReplayController {
            constructor(data, initialState = {}) {
                this.data = data;
                this.state = {
                    currentTickIndex: 0,
                    playbackSpeed: 1000,
                    isPaused: true,
                    ...initialState
                };
                this.animationFrameId = null;
                this.lastUpdate = 0;
                this.onTickChange = null;
            }
            
            play() {
                if (this.state.isPaused) {
                    this.state.isPaused = false;
                    this.lastUpdate = performance.now();
                    this.startPlaybackLoop();
                }
            }
            
            pause() {
                this.state.isPaused = true;
                if (this.animationFrameId !== null) {
                    cancelAnimationFrame(this.animationFrameId);
                    this.animationFrameId = null;
                }
            }
            
            stop() {
                this.pause();
                this.state.currentTickIndex = 0;
                this.onTickChange?.(this.state.currentTickIndex);
            }
            
            step(direction) {
                const step = direction === 'forward' ? 1 : -1;
                const newIndex = this.state.currentTickIndex + step;
                this.seek(newIndex);
            }
            
            seek(index) {
                const clampedIndex = Math.max(0, Math.min(index, this.data.length - 1));
                if (clampedIndex !== this.state.currentTickIndex) {
                    this.state.currentTickIndex = clampedIndex;
                    this.onTickChange?.(this.state.currentTickIndex);
                }
            }
            
            setSpeed(speed) {
                this.state.playbackSpeed = Math.max(10, speed);
            }
            
            setOnTickChange(callback) {
                this.onTickChange = callback;
            }
            
            getCurrentTickIndex() {
                return this.state.currentTickIndex;
            }
            
            getPlaybackSpeed() {
                return this.state.playbackSpeed;
            }
            
            isPaused() {
                return this.state.isPaused;
            }
            
            getProgress() {
                if (this.data.length <= 1) return 0;
                return this.state.currentTickIndex / (this.data.length - 1);
            }
            
            setProgress(progress) {
                const index = Math.round(progress * (this.data.length - 1));
                this.seek(index);
            }
            
            startPlaybackLoop() {
                const loop = (timestamp) => {
                    if (!this.state.isPaused) {
                        if (timestamp - this.lastUpdate >= this.state.playbackSpeed) {
                            if (this.state.currentTickIndex < this.data.length - 1) {
                                this.state.currentTickIndex++;
                                this.onTickChange?.(this.state.currentTickIndex);
                                this.lastUpdate = timestamp;
                            } else {
                                this.pause();
                            }
                        }
                        
                        if (!this.state.isPaused && this.state.currentTickIndex < this.data.length - 1) {
                            this.animationFrameId = requestAnimationFrame(loop);
                        } else {
                            this.animationFrameId = null;
                        }
                    }
                };
                
                this.animationFrameId = requestAnimationFrame(loop);
            }
        }

        // Initialize demo
        const canvas = document.getElementById('chartCanvas');
        const ctx = canvas.getContext('2d');
        const data = generateSampleData(2000);
        const dimensions = { width: canvas.clientWidth, height: canvas.clientHeight };
        const coordinateManager = new DemoCoordinateManager(data, dimensions, 10, 0);
        const replayController = new DemoReplayController(data, { playbackSpeed: 1000 });
        
        // Enable pixel-perfect rendering
        ctx.imageSmoothingEnabled = false;
        ctx.mozImageSmoothingEnabled = false;
        ctx.webkitImageSmoothingEnabled = false;
        ctx.msImageSmoothingEnabled = false;
        
        let animationId = null;
        let lastFrameTime = 0;
        let frameCount = 0;
        let fps = 0;
        let isInteracting = true;
        
        // Handle resize
        window.addEventListener('resize', () => {
            dimensions.width = canvas.clientWidth;
            dimensions.height = canvas.clientHeight;
            coordinateManager.state.canvasDimensions = dimensions;
            
            // Re-apply pixel-perfect settings after resize
            ctx.imageSmoothingEnabled = false;
            ctx.mozImageSmoothingEnabled = false;
            ctx.webkitImageSmoothingEnabled = false;
            ctx.msImageSmoothingEnabled = false;
        });

        // Animation loop with dirty flag optimization
        function animate(timestamp) {
            if (!lastFrameTime) lastFrameTime = timestamp;
            
            frameCount++;
            if (timestamp - lastFrameTime >= 1000) {
                fps = frameCount;
                frameCount = 0;
                lastFrameTime = timestamp;
                updateStats();
            }
            
            draw();
            animationId = requestAnimationFrame(animate);
        }

        // Drawing functions with Fog of War
        function draw() {
            const { width, height } = dimensions;
            
            // Clear canvas
            ctx.clearRect(0, 0, width, height);
            
            // Draw background
            ctx.fillStyle = '#1e1e1e';
            ctx.fillRect(0, 0, width, height);
            
            // Draw grid
            drawGrid();
            
            // Draw candles with Fog of War
            drawCandlesWithFogOfWar();
            
            // Draw FPS
            ctx.fillStyle = '#fff';
            ctx.font = '12px Arial';
            ctx.fillText(`FPS: ${fps}`, 10, 20);
        }

        function drawGrid() {
            const { width, height } = dimensions;
            const { min, max } = coordinateManager.getMinMaxPrice();
            
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            ctx.setLineDash([2, 4]);
            
            // Draw horizontal grid lines
            const range = max - min;
            const step = Math.pow(10, Math.floor(Math.log10(range)) - 1);
            const start = Math.floor(min / step) * step;
            
            for (let price = start; price <= max; price += step) {
                if (price >= min) {
                    const y = coordinateManager.priceToY(price);
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(width, y);
                    ctx.stroke();
                }
            }
            
            ctx.setLineDash([]);
        }

        function drawCandlesWithFogOfWar() {
            const { startIndex, endIndex } = coordinateManager.getVisibleRange();
            const currentTickIndex = replayController.getCurrentTickIndex();
            
            for (let i = startIndex; i <= endIndex; i++) {
                const candle = data[i];
                if (!candle) continue;
                
                const x = coordinateManager.timeToX(i);
                const openY = coordinateManager.priceToY(candle.open);
                const closeY = coordinateManager.priceToY(candle.close);
                const highY = coordinateManager.priceToY(candle.high);
                const lowY = coordinateManager.priceToY(candle.low);
                
                // Determine if candle is revealed or ghost
                const isRevealed = i <= currentTickIndex;
                const opacity = isRevealed ? 1.0 : 0.1;
                
                // Draw wick with appropriate opacity
                ctx.globalAlpha = opacity;
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1;
                const wickX = Math.round(x);
                const wickHighY = Math.round(highY);
                const wickLowY = Math.round(lowY);
                
                ctx.beginPath();
                ctx.moveTo(wickX, wickHighY);
                ctx.lineTo(wickX, wickLowY);
                ctx.stroke();
                
                // Draw body with appropriate opacity and color
                const bodyX = Math.round(x - 3);
                const bodyY = Math.round(Math.min(openY, closeY));
                const bodyHeight = Math.max(Math.abs(Math.round(closeY) - Math.round(openY)), 1);
                const isBullish = candle.close >= candle.open;
                
                const baseColor = isBullish ? '#00ff00' : '#ff0000';
                ctx.fillStyle = setOpacity(baseColor, opacity);
                ctx.fillRect(bodyX, bodyY, 6, bodyHeight);
                
                // Reset opacity
                ctx.globalAlpha = 1.0;
            }
        }

        function setOpacity(color, opacity) {
            const hex = color.replace('#', '');
            const r = parseInt(hex.substring(0, 2), 16);
            const g = parseInt(hex.substring(2, 4), 16);
            const b = parseInt(hex.substring(4, 6), 16);
            return `rgba(${r}, ${g}, ${b}, ${opacity})`;
        }

        function updateStats() {
            const { startIndex, endIndex } = coordinateManager.getVisibleRange();
            const stats = document.getElementById('stats');
            const modeDisplay = document.getElementById('modeDisplay');
            const currentPrice = document.getElementById('currentPrice');
            const replayStatus = document.getElementById('replayStatus');
            
            // Get current price at center of screen
            const centerIndex = Math.floor((startIndex + endIndex) / 2);
            const centerCandle = data[centerIndex];
            const priceText = centerCandle ? centerCandle.close.toFixed(2) : '-';
            
            stats.innerHTML = `
                FPS: ${fps} | 
                Zoom: ${coordinateManager.getZoom().toFixed(2)} | 
                Offset: ${coordinateManager.getOffset().toFixed(0)} | 
                Visible: ${startIndex} - ${endIndex} | 
                Data: ${data.length} candles | 
                Tick: ${replayController.getCurrentTickIndex()} | 
                Speed: ${replayController.getPlaybackSpeed()}ms
            `;
            
            modeDisplay.textContent = replayController.isPaused() ? 'Paused' : 'Playing';
            currentPrice.textContent = priceText;
            replayStatus.textContent = replayController.isPaused() ? 'Paused' : 'Playing';
        }

        // Event handlers
        canvas.addEventListener('wheel', (e) => {
            if (!isInteracting) return;
            e.preventDefault();
            const delta = e.deltaY;
            const currentZoom = coordinateManager.getZoom();
            const newZoom = Math.max(1, Math.min(100, currentZoom + (delta * 0.01)));
            
            // Apply zoom-to-cursor logic
            const mouseX = e.clientX - canvas.getBoundingClientRect().left;
            applyZoomToCursor(newZoom, mouseX);
            
            updateStats();
        }, { passive: false });

        let isDragging = false;
        let lastMouseX = 0;
        let lastMouseY = 0;

        canvas.addEventListener('mousedown', (e) => {
            if (!isInteracting) return;
            isDragging = true;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            canvas.style.cursor = 'grabbing';
        });

        window.addEventListener('mouseup', () => {
            isDragging = false;
            canvas.style.cursor = 'crosshair';
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!isInteracting || !isDragging) return;
            
            const deltaX = e.clientX - lastMouseX;
            const deltaY = e.clientY - lastMouseY;
            
            // Horizontal panning (time axis)
            const currentOffset = coordinateManager.getOffset();
            coordinateManager.setOffset(currentOffset - deltaX);
            
            // Vertical panning (price axis) - Alt key + drag
            if (e.altKey) {
                const currentPriceOffset = coordinateManager.getPriceOffset();
                coordinateManager.setPriceOffset(currentPriceOffset + deltaY);
            }
            
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            updateStats();
        });

        canvas.addEventListener('dblclick', (e) => {
            if (!isInteracting) return;
            e.preventDefault();
            coordinateManager.setZoom(10);
            coordinateManager.setOffset(0);
            coordinateManager.setPriceOffset(0);
            updateStats();
        });

        // Zoom-to-cursor implementation
        function applyZoomToCursor(newZoom, mouseX) {
            const currentZoom = coordinateManager.getZoom();
            const currentOffset = coordinateManager.getOffset();
            
            // Calculate the candle index under the cursor
            const candleIndex = coordinateManager.getIndexAtX ? 
                coordinateManager.getIndexAtX(mouseX) : 
                Math.floor((mouseX + currentOffset) / currentZoom);
            
            if (candleIndex === -1) {
                coordinateManager.setZoom(newZoom);
                return;
            }
            
            // Calculate the X position of the candle
            const candleX = coordinateManager.timeToX(candleIndex);
            
            // Calculate how much the offset needs to change to keep the candle under the cursor
            const offsetAdjustment = (newZoom - currentZoom) * candleIndex;
            
            // Apply the changes
            coordinateManager.setZoom(newZoom);
            coordinateManager.setOffset(currentOffset + offsetAdjustment);
        }

        // Control functions
        window.resetView = () => {
            coordinateManager.setZoom(10);
            coordinateManager.setOffset(0);
            coordinateManager.setPriceOffset(0);
            updateStats();
        };

        window.toggleInteraction = () => {
            isInteracting = !isInteracting;
            canvas.style.cursor = isInteracting ? 'crosshair' : 'default';
            canvas.style.pointerEvents = isInteracting ? 'auto' : 'none';
        };

        window.playReplay = () => {
            replayController.play();
            updateStats();
        };

        window.pauseReplay = () => {
            replayController.pause();
            updateStats();
        };

        window.stopReplay = () => {
            replayController.stop();
            updateStats();
        };

        window.stepForward = () => {
            replayController.step('forward');
            updateStats();
        };

        window.stepBackward = () => {
            replayController.step('backward');
            updateStats();
        };

        window.updateSpeed = (speed) => {
            const speedNum = parseInt(speed);
            replayController.setSpeed(speedNum);
            document.getElementById('speedValue').textContent = speedNum;
            updateStats();
        };

        window.seekProgress = (progress) => {
            const progressNum = parseInt(progress) / 100;
            replayController.setProgress(progressNum);
            document.getElementById('progressValue').textContent = `${Math.round(progressNum * 100)}%`;
            updateStats();
        };

        // Set up replay controller tick change callback
        replayController.setOnTickChange((tickIndex) => {
            document.getElementById('progressSlider').value = Math.round(tickIndex / (data.length - 1) * 100);
            document.getElementById('progressValue').textContent = `${Math.round(tickIndex / (data.length - 1) * 100)}%`;
            updateStats();
        });

        // Start animation
        animate();
    </script>
</body>
</html>